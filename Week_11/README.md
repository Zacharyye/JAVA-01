学习笔记

# 第21课 分布式缓存 - 缓存技术

### 1.从数据的使用说起

- 把数据的使用频率和方式分个类
  - 静态数据 - 一般不变，类似于字典表
  - 准静态数据 - 变化频率很低，部门结构设置，全国行政区划数据等
  - 中间状态数据 - 一些计算的可复用中间数据，变量副本，配置中心的本地副本。
  - ～
  - 热数据 - 使用频率高
  - 读写比较大 - 读的频率 >> 写的频率
  - 这些数据适合于使用缓存的方式访问
  - 广义上来说，为了加速数据处理，让业务更快访问的临时存放冗余数据，都是缓存狭义上，现在一般在分布式系统里把缓存到内存的数据叫做内存缓存。
- 缓存无处不在
  - 内存 ～ 可以看作是CPU和磁盘之间的缓存
  - CPU与内存的处理速度也不一致，出现L1&L2 Cache
  - 网络处理，数据库引擎的各种Buffer，都可以看作是缓存
  - GUI的Double Buffer（双缓存），是一个经典的性能优化方法
  - 缓存的本质
    - 系统各级处理速度不匹配，导致利用空间换时间
  - 缓存是提升系统性能的一个简单有效的方法。
- 缓存加载时机
  - 启动全量加载 => 全局有效，使用简单
  - 懒加载
    -  同步使用加载
      - 先看缓存是否有数据，没有的话从数据库读取
      - 读取的数据，先放到内存，然后返回给调用方
    - 延迟异步加载
      - 从缓存获取数据，不管是否为空直接返回
      - 策略1异步）如果为空，则发起一个异步加载的线程，负责加载数据
      - 策略2解耦）异步线程负责维护缓存的数据，定期或根据条件触发更新。
- 缓存的有效性与数据同步
  - 为什么一般说变动频率大、一致性要求高的数据，不太适合用缓存
    - 变化大，意味着内存缓存数据<-->原始数据库数据，一直有差异；一致性要求高，意味着只有使用原始数据，甚至加了事务，才是保险的。
  - 如何评价缓存的有效性
    - 读写比：对数据的写操作导致数据变动，意味着维护成本N：1
    - 命中率：命中维护意味着缓存数据被使用，意味着有价值。90%+
  - 对于数据一致性、性能、成本的综合衡量，是引入缓存的必须指标。
- 缓存使用不当导致的问题
  - 系统预热导致启动慢
    - 试想，一个系统启动需要预热半个小时；导致系统不能做到快速应对故障宕机等问题
  - 系统内存资源耗尽
    - 只加入数据，不能清理旧数据
    - 旧数据处理不及时，或者不能有效识别无用数据。

### 2.本地缓存

- 最简单的本地缓存

  - ```java
    public static final Map<String,Object> CACHE = new HashKap();
    CACHE.put("beijing", "100001");
    String cityCode = (String) CACHE.get("beijing");
    ```

- Hibernate/MyBatis都有Cache

  - 一级缓存，session级别
  - 二级缓存，sessionFactory级别

-  Guava Cache

  - ```java
    Cache<String, String> cache = CacheBuilder.newBuilder()
    	.maximumSize(1024)
    	.expireAfterWrite(60, TimeUnit.SECONDS)
    	.weakValues()
    	.build();
    cache.put("word", "Hello Guava Cache");
    System.out.println(cache.getIfPresent("word"));
    ```

  - 此外，还可以显示清楚、统计信息、移除事件的监听器、自动加载等功能。

- Spring Cache

  - 基于注解和AOP

### 3.远程缓存

### 4.缓存策略

### 5.缓存常见问题

### 6.总结

