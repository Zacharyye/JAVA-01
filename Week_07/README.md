学习笔记

# 第13课 性能与SQL优化（2）

### 1.MySQL事务与锁 *

- 事务可靠性模型ACID
  - Atomicity：原子性，一次事务中的操作要么全部成功，要么全部失败
  - Consistency：一致性，跨表、跨行、跨事务，数据库始终保持一致状态
  - Isolation：隔离性，可见性，保护事务不会互相干扰，包含4种隔离级别
  - Durability：持久性，事务提交成功后，不会丢数据。如电源故障，系统崩溃
- InnoDB
  - 双写缓冲区、故障恢复、操作系统、fsync()、磁盘存储、缓存、UPS、网络、备份策略......
- 表级锁
  - 意向锁：表明事务稍后要进行哪种类型的锁定
    - 共享意向锁（IS）：打算在某些行上设置共享锁
    - 排他意向锁（IX）：打算对某些行设置排他锁
    - Insert意向锁：Insert操作设置的间隙锁
  - 其他
    - 自增锁（AUTO-IN）
    - LOCK TABLES/DDL
- 行级锁
  - 记录锁（Record）：始终锁定索引记录，注意隐藏的聚簇索引
  - 间隙锁（GAP）：
  - 临键锁（Next-Key）：记录锁+间隙锁的组合；可“锁定”表中不存在记录
  - 谓词锁（Predicat）：空间索引
- 死锁
  - 阻塞与互相等待
  - 增删改，锁定读
  - 死锁检测与自动回滚
  - 锁粒度与程序设计
- 四种事务隔离级别
  - 读未提交：READ UNCOMMITTED
    - 很少使用
    - 不能保证一致性
    - 脏读（dirty read）：使用到从未被确认的数据（例如：早期版本、回滚）
    - 锁：
      - 以非锁定方式执行
      - 可能的问题：脏读、幻读、不可重复读
  - 读已提交：READ COMMITED
    - 每次查询都会设置和读取自己的新快照
    - 仅支持基于行的bin-log
    - UPDATE优化：半一致性（semi-consistent read）
    - 不可重复读：不加锁的情况下，其他事务UPDATE或DELETE会对查询结果有影响
    - 幻读（Phantom）：加锁后，不锁定间隙，其他事务可以INSERT。
    - 锁：
      - 锁定索引记录，而不锁定记录之间的间隙
      - 可能的问题：幻读、不可重复读
  - 可重复读：REPEATABLE READ
    - InnoDB的默认隔离级别
    - 使用事务第一次读取时创建的快照
    - 多版本技术
    - 锁
      - 使用唯一索引的唯一查询条件时，只锁定查找到的索引记录，不锁定间隙
      - 其他查询条件，会锁定扫描到的索引范围，通过间隙锁或临键锁来组织其他会话在这个范围汇总插入值
      - 可能的问题：InnoDB不能保证没有幻读，需要加锁
  - 可串行化：SERIALIZABLE
    - 最严格的级别，事务串行执行，资源消耗最大
  - undo log
    - 撤销日志
    - 保证事务的原子性
    - 用处：事务回滚，一致性读、崩溃恢复
    - 记录事务回滚时所需的撤销操作
    - 一条INSERT语句，对应一条DELETE的undo log
    - 每个UPDATE语句，对应一条相反的UPDATE的undo log
    - 保存位置
      - system tablespace - 5.7默认
      - undo tablespace - 8.0默认
    - 回滚段
  - redo log：重做日志
    - 确保事务的持久性，防止事务提交后数据未刷新到磁盘就掉电或崩溃
    - 事务执行过程中写入redo log，记录事务对数据页做了哪些修改
    - 提升性能：WAL（Write-Ahead Logging）技术，先写日志，再写磁盘
    - 日志文件：ib_logfile0,ib_logfile1
    - 日志缓冲：innodb_log_buffer_size
    - 强刷：sync()
  - MVCC：多版本并发控制
    - 使InnoDB支持一致性读
    - 让查询不被阻塞，无需等待被其他事务持有的锁，这种技术手段可以增加并发性能
    - InnoDB保留被修改行的旧版本
    - 查询正在被其他事务更新的数据时，会读取更新之前的版本
- 事务隔离是数据库的基础特征
- MySQL
  - 可以设置全局的默认隔离级别
  - 可以单独设置会话的隔离级别
  - InnoDB实现与标准之间的差异

### 2.DB与SQL优化 *

- 慢查询日志重点
  - rank
  - response time
  - Rows examine
  - min
- 修改表结构的危害
  - 索引重建
  - 锁表
  - 抢占资源
  - 主从延时

### 3.常见场景分析 *

- 怎么实现主键ID
  - 自增
  - sequence
  - 模拟seq
  - UUID
  - 时间戳/随机数
  - snowflake

### 4.回顾



# 第14课 超越分库分表 - 高可用与读写分离

### 1.从单机到集群

> 随着数据量的增大，读写并发的增加，系统可用性要求的提升，单机MySQL面临：
>
> - 容量有限，难以扩容
> - 读写压力，QPS过大，特别是分析类需求会影响到业务事务
> - 可用性不足，宕机问题

### 2.MySQL主从复制

> - 主从复制原理
>   - 核心
>     - 主库写binlog
>     - 从库relay log
>   - Binlog格式
>     - ROW
>     - Statement
>     - Mixed
>   - 异步复制：网络或机器故障，会造成数据不一致                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
>   - 半同步复制：需要启用插件
>   - 组复制：MySQL Group Replication（MGR）
>     - 组复制，基于分布式Paxos协议实现组复制，保证数据一致性
> - 主从复制演示
>   - 本地启动两个MySQL
>   - 注意配置文件（思考几种安装、启动方式）
>   - 演示数据复制操作，创建表和写入、修改数据
> - 主从复制的局限性
>   -  主从延迟问题
>   - 应用侧需要配合读写分离框架
>   - 不解决高可用问题　　　　　　　

### 3.MySQL读写分离

> - 主从复制在业务系统里的应用
>   - 借助于主从复制，可以有多个MySQL服务器示例
>   - 如果借助这个新的集群，改进业务系统数据处理能力
>     - 配置多个数据源，实现读写分离
> - 读写分离-动态切换数据源版本1.0
>   - 基于Spring/Spring Boot，配置多个数据源（例如2个，master和slave）
>   - 根据具体的Service方法是否会操作数据，注入不同的数据源，1.0版本
>   - 改进一下1.1:基于操作AbstractRoutingDataSource和自定义注解readOnly之类的，简化自动切换数据源
>   - 改进二下1.2:支持配置多个从库
>   - 改进三下1.3:支持多个从库的负载均衡
> - 读写分离 - 数据库框架版本2.0
>   - 前一版本“动态切换数据源”有什么问题？
>     - 侵入性还是较强
>     - 降低侵入性会导致“写完读”不一致问题
>   - 改进方式，ShardingSphere-jdbc的Master-Slave功能
>     - SQL解析和事务管理，自动实现读写分离
>     - 解决“写完读”不一致的问题
> - 读写分离-数据库中间件版本3.0
>   - 前一版本“框架版本”的问题
>     - 对业务系统还是有侵入
>     - 对已存在的旧系统改造不友好
>   - 改进方式，MyCat/ShardingSphere-Proxy的Master-Slave功能
>     - 需要部署一个中间件，规则配置在中间件
>     - 模拟一个MySQL服务器，对业务系统无侵入

### 4.MySQL高可用

> - 为什么要高可用
>   - 读写分离，提升读的处理能力
>   - 故障转移，提供failover能力
>   - 加上业务侧连接池的心跳重试，实现短线重连，业务不间断，降低RTO和RPO
> - 高可用定义
>   - 高可用意味着，更少的不可服务时间，一般用SLA/SLO衡量
> - 为什么要高可用
>   - 什么是failover，故障转移，灾难恢复
>   - 容灾：热备和冷备
>   - 对于主从来说，简单讲就是主挂了，某一个从，编程主
>   - 整个集群来看，正常对外提供服务
>   - 常见的一些策略：
>     - 多个实例不在一个主机/机架上
>     - 跨机房和可用区部署
>     - 两地三中心容灾高可用方案
> - MySQL高可用0:主从手动切换
>   - 如果主节点挂掉，将某个从改正主
>   - 重新配置其他从节点
>   - 修改应用数据源配置
>   - 问题：
>     - 可能数据不一致
>     - 需要人工干预
>     - 代码和配置的侵入性
> - MySQL高可用1:主从手动切换
>   - 用LVS+Keepalived实现多个节点的探活+请求路由
>   - 配置VIP或DNS实现配置不变更
>   - 问题：
>     - 手工处理主从切换
>     - 大量的配置和脚本定义
> - MySQL高可用2:MHA
>   - MHA（Master High Availablity）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司的youshimaton开发，是一套优秀的作为MySQL高可用环境下故障切换和主从提升的高可用软件
>   - 基于Perl语言开发，一般能在30s内实现主从切换
>   - 切换时，直接通过SSH复制主节点的日志
>   - 问题：
>     - 需要配置SSH信息
>     - 至少3台
> - MySQL高可用3:MGR*
>   - 如果主节点挂掉，将自动选择某个从改成主
>   - 无需人工干预，基于组复制，保证数据一致性
>   - 问题：
>     - 外部获得状态变更需要读取数据库
>     - 外部需要使用lVS/VIP配置
>   - 特点
>     - 高一致性：基于分布式Paxos协议实现组复制，保证数据一致性
>     - 高容错性：自动检测机制，只要不是大多数节点都宕机就可以继续工作，内置防脑裂保护机制
>     - 高扩展性：节点的增加与移除会自动更新组成员信息，新节点加入后，自动从其他节点同步增量数据，直到与其他节点数据一致
>     - 高灵活性：提供单主模式和多主模式，单主模式在主哭宕机后能够自动选择，所有写入都在主节点进行，多主模式支持多节点写入
>   - 使用场景
>     - 弹性复制：服务器数量以低代价增加或者减少
>     - 高可用分片：分片是一种实现写扩展的流行方式。可以使用MySQL组复制来实现高可用分片。每一个分片映射到一个复制组。
> - MySQL高可用4:MySQL Cluster
>   - 完整的数据库层高可用解决方案
>     - MySQL InnoDB Cluster是一个高可用的框架，它由下面这几个组件构成
>       - MySQL Group Replication：提供DB的扩展、自动故障转移
>       - MySQL Router：轻量级中间件，提供应用程序连接目标的故障转移
>       - MySQL Shell：新的MySQL客户端，多种接口模式。可以设置群组复制及Router
> - MySQL高可用5:Orchestrator
>   - 如果主节点挂掉，将某个从改成主：
>     - orchestrator：一款MySQL高可用和复制拓扑管理工具，支持复制拓扑结构的调整，自动故障转移和手动主从切换等。后端数据库用MySQL或SQLite存储元数据，并提供Web界面展示MySQL复制的拓扑关系及状态，通过Web可更改MySQL实例的复制关系和部分配置信息，同时也提供命令行和API接口，方便运维管理。
>   - 特点：
>     - 自动发现MySQL的复制拓扑，并且在Web上展示
>     - 重构复制关系，可以在Web进行拖图来进行复制关系变更
>     - 检测主异常，并可以自动或手动恢复，通过Hooks进行自定义脚本
>     - 支持命令行和web界面管理复制

### 5.总结回顾



